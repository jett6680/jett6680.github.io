import{_ as u,o as b,c as D,O as h}from"./chunks/framework.64ff6dc7.js";const s="/assets/img_15.png",a="/assets/img_16.png",o="/assets/img_17.png",n="/assets/img_18.png",l="/assets/img_19.png",t="/assets/img_20.png",p="/assets/img_21.png",e="/assets/img_22.png",r="/assets/img_23.png",c="/assets/img_24.png",i="/assets/img_25.png",g="/assets/img_26.png",d="/assets/img_27.png",S=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"web/browser/q3.md"}'),m={name:"web/browser/q3.md"},C=h('<h2 id="渲染流程" tabindex="-1">渲染流程 <a class="header-anchor" href="#渲染流程" aria-label="Permalink to &quot;渲染流程&quot;">​</a></h2><blockquote><p>导航被提交后,就进入了渲染阶段。渲染模流程在执行过程中会被划分为很多子阶段， 输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做<strong>渲染流水线</strong></p></blockquote><p>其大致流程如下图所示：</p><p><img src="'+s+'" alt=""></p><blockquote><p>按照渲染的时间顺序，流水线可分为如下几个子阶段：<strong>构建 DOM 树</strong>、<strong>样式计算</strong>、 <strong>布局阶段</strong>、<strong>分层</strong>、<strong>绘制</strong>、<strong>分块</strong>、<strong>光栅化</strong>和<strong>合成</strong>。</p></blockquote><h2 id="构建-dom-树" tabindex="-1">构建 DOM 树 <a class="header-anchor" href="#构建-dom-树" aria-label="Permalink to &quot;构建 DOM 树&quot;">​</a></h2><blockquote><p>浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——<strong>DOM树</strong>。</p></blockquote><p>如图: <img src="'+a+'" alt=""></p><p>DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构， 可以通过 JavaScript 来查询或修改其内容。</p><h2 id="样式计算" tabindex="-1">样式计算 <a class="header-anchor" href="#样式计算" aria-label="Permalink to &quot;样式计算&quot;">​</a></h2><blockquote><p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式</p></blockquote><h3 id="_1-把-css-转换为浏览器能够理解的结构" tabindex="-1">1.把 CSS 转换为浏览器能够理解的结构 <a class="header-anchor" href="#_1-把-css-转换为浏览器能够理解的结构" aria-label="Permalink to &quot;1.把 CSS 转换为浏览器能够理解的结构&quot;">​</a></h3><p>CSS 样式来源主要有三种：</p><ul><li>通过 link 引用的外部 CSS 文件</li><li>style标签内的css</li><li>元素的style熟悉内嵌的css</li></ul><p><strong>渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。</strong></p><p><img src="'+o+`" alt=""></p><h3 id="_2-转换样式表中的属性值-使其标准化" tabindex="-1">2. 转换样式表中的属性值，使其标准化 <a class="header-anchor" href="#_2-转换样式表中的属性值-使其标准化" aria-label="Permalink to &quot;2. 转换样式表中的属性值，使其标准化&quot;">​</a></h3><div class="language-css line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">body</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#B2CCD6;">font-size</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2em</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#FFCB6B;">p</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#B2CCD6;">color</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;">blue</span><span style="color:#89DDFF;">;}</span></span>
<span class="line"><span style="color:#FFCB6B;">span</span><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span><span style="color:#B2CCD6;">display</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> none</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#FFCB6B;">div</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#B2CCD6;">font-weight</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> bold</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#FFCB6B;">div</span><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">p</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#B2CCD6;">color</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;">green</span><span style="color:#89DDFF;">;}</span></span>
<span class="line"><span style="color:#FFCB6B;">div</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#B2CCD6;">color</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;">red</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值</p></blockquote><p>标准化后的值 <img src="`+n+'" alt=""></p><h3 id="_3-计算出-dom-树中每个节点的具体样式" tabindex="-1">3. 计算出 DOM 树中每个节点的具体样式 <a class="header-anchor" href="#_3-计算出-dom-树中每个节点的具体样式" aria-label="Permalink to &quot;3. 计算出 DOM 树中每个节点的具体样式&quot;">​</a></h3><p>根据css的<strong>继承</strong>和<strong>层叠</strong>规则，为每个DOM节点计算出最终样式,并保存再computedStyle结构中</p><p><img src="'+l+'" alt=""></p><h2 id="布局阶段" tabindex="-1">布局阶段 <a class="header-anchor" href="#布局阶段" aria-label="Permalink to &quot;布局阶段&quot;">​</a></h2><blockquote><p>有了DOM树和DOM树的样式，还不能显示页面。因为元素的几何位置信息还不知道； 需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做<strong>布局</strong>。</p></blockquote><h3 id="_1-创建布局树" tabindex="-1">1.创建布局树 <a class="header-anchor" href="#_1-创建布局树" aria-label="Permalink to &quot;1.创建布局树&quot;">​</a></h3><p>DOM树含有很多不可见的元素，比如head标签，或者display:none的元素，所以再显示之前， 需要额外的构建一颗<strong>只包含可见元素的布局树</strong></p><p>为了构建布局树，浏览器大体上完成了下面这些工作：</p><p><img src="'+t+'" alt=""></p><ul><li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；</li><li>而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。</li></ul><h3 id="_2-布局计算" tabindex="-1">2.布局计算 <a class="header-anchor" href="#_2-布局计算" aria-label="Permalink to &quot;2.布局计算&quot;">​</a></h3><p>这个阶段主要计算布局树节点的坐标位置，把布局运算的结果写到布局树中保存起来；</p><h2 id="分层" tabindex="-1">分层 <a class="header-anchor" href="#分层" aria-label="Permalink to &quot;分层&quot;">​</a></h2><blockquote><p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等， 为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）</strong></p></blockquote><blockquote><p>渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面</p></blockquote><p>图层和布局树节点之间的关系:</p><p><img src="'+p+'" alt=""></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</p></div><p>渲染引擎会为以下情况的节点创建新的图层：</p><ul><li>拥有层叠上下文属性的元素会被提升为单独的一层</li><li>需要剪裁（clip）的地方也会被创建为图层</li></ul><h2 id="绘制" tabindex="-1">绘制 <a class="header-anchor" href="#绘制" aria-label="Permalink to &quot;绘制&quot;">​</a></h2><blockquote><p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制</p></blockquote><p>渲染引擎实现图层的绘制跟我们绘制canvas类似，会把一个图层的绘制拆分成很多小的绘制指令， 然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</p><p><img src="'+e+'" alt=""></p><p>实际的绘制列表可以再chrome devtools的layers标签查看:</p><p><img src="'+r+'" alt=""></p><h2 id="光栅化-分块" tabindex="-1">光栅化 &amp; 分块 <a class="header-anchor" href="#光栅化-分块" aria-label="Permalink to &quot;光栅化 &amp; 分块&quot;">​</a></h2><blockquote><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的</p></blockquote><p><img src="'+c+'" alt=""></p><p>当图层的绘制列表准备好之后，主线程会把该绘制列表<strong>提交commit</strong>给合成线程</p><blockquote><p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口， 用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销， 而且也没有必要。</p></blockquote><p>基于这个原因，合成线程会将图层划分为<strong>图块（tile）</strong></p><blockquote><p>图块的大小通常是 256x256 或者 512x512</p></blockquote><p><strong>合成线程</strong>会按照视口附近的图块来优先生成位图，实际生成位图的操作是由<strong>栅格化</strong>来执行的。 所谓栅格化，是指将图块转换为<strong>位图</strong></p><p><img src="'+i+'" alt=""></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>图块是栅格化执行的最小单位</p></div><p>通常，栅格化过程都会使用 <strong>GPU</strong> 来加速生成，使用 <strong>GPU</strong> 生成位图的过程叫<strong>快速栅格化</strong>，或者 <strong>GPU</strong> 栅格化，生成的位图被保存在 <strong>GPU</strong> 内存中。</p><p><strong>快速栅格化：</strong><img src="'+g+'" alt=""></p><blockquote><p>渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。</p></blockquote><h2 id="合成显示-渲染流程" tabindex="-1">合成显示## 渲染流程 <a class="header-anchor" href="#合成显示-渲染流程" aria-label="Permalink to &quot;合成显示## 渲染流程&quot;">​</a></h2><blockquote><p>导航被提交后,就进入了渲染阶段。渲染模流程在执行过程中会被划分为很多子阶段， 输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做<strong>渲染流水线</strong></p></blockquote><p>其大致流程如下图所示：</p><p><img src="'+s+'" alt=""></p><blockquote><p>按照渲染的时间顺序，流水线可分为如下几个子阶段：<strong>构建 DOM 树</strong>、<strong>样式计算</strong>、 <strong>布局阶段</strong>、<strong>分层</strong>、<strong>绘制</strong>、<strong>分块</strong>、<strong>光栅化</strong>和<strong>合成</strong>。</p></blockquote><h2 id="构建-dom-树-1" tabindex="-1">构建 DOM 树 <a class="header-anchor" href="#构建-dom-树-1" aria-label="Permalink to &quot;构建 DOM 树&quot;">​</a></h2><blockquote><p>浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——<strong>DOM树</strong>。</p></blockquote><p>如图: <img src="'+a+'" alt=""></p><p>DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构， 可以通过 JavaScript 来查询或修改其内容。</p><h2 id="样式计算-1" tabindex="-1">样式计算 <a class="header-anchor" href="#样式计算-1" aria-label="Permalink to &quot;样式计算&quot;">​</a></h2><blockquote><p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式</p></blockquote><h3 id="_1-把-css-转换为浏览器能够理解的结构-1" tabindex="-1">1.把 CSS 转换为浏览器能够理解的结构 <a class="header-anchor" href="#_1-把-css-转换为浏览器能够理解的结构-1" aria-label="Permalink to &quot;1.把 CSS 转换为浏览器能够理解的结构&quot;">​</a></h3><p>CSS 样式来源主要有三种：</p><ul><li>通过 link 引用的外部 CSS 文件</li><li>style标签内的css</li><li>元素的style熟悉内嵌的css</li></ul><p><strong>渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。</strong></p><p><img src="'+o+`" alt=""></p><h3 id="_2-转换样式表中的属性值-使其标准化-1" tabindex="-1">2. 转换样式表中的属性值，使其标准化 <a class="header-anchor" href="#_2-转换样式表中的属性值-使其标准化-1" aria-label="Permalink to &quot;2. 转换样式表中的属性值，使其标准化&quot;">​</a></h3><div class="language-css line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">body</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#B2CCD6;">font-size</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2em</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#FFCB6B;">p</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#B2CCD6;">color</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;">blue</span><span style="color:#89DDFF;">;}</span></span>
<span class="line"><span style="color:#FFCB6B;">span</span><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span><span style="color:#B2CCD6;">display</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> none</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#FFCB6B;">div</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#B2CCD6;">font-weight</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> bold</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#FFCB6B;">div</span><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">p</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#B2CCD6;">color</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;">green</span><span style="color:#89DDFF;">;}</span></span>
<span class="line"><span style="color:#FFCB6B;">div</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#B2CCD6;">color</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;">red</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值</p></blockquote><p>标准化后的值 <img src="`+n+'" alt=""></p><h3 id="_3-计算出-dom-树中每个节点的具体样式-1" tabindex="-1">3. 计算出 DOM 树中每个节点的具体样式 <a class="header-anchor" href="#_3-计算出-dom-树中每个节点的具体样式-1" aria-label="Permalink to &quot;3. 计算出 DOM 树中每个节点的具体样式&quot;">​</a></h3><p>根据css的<strong>继承</strong>和<strong>层叠</strong>规则，为每个DOM节点计算出最终样式,并保存再computedStyle结构中</p><p><img src="'+l+'" alt=""></p><h2 id="布局阶段-1" tabindex="-1">布局阶段 <a class="header-anchor" href="#布局阶段-1" aria-label="Permalink to &quot;布局阶段&quot;">​</a></h2><blockquote><p>有了DOM树和DOM树的样式，还不能显示页面。因为元素的几何位置信息还不知道； 需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做<strong>布局</strong>。</p></blockquote><h3 id="_1-创建布局树-1" tabindex="-1">1.创建布局树 <a class="header-anchor" href="#_1-创建布局树-1" aria-label="Permalink to &quot;1.创建布局树&quot;">​</a></h3><p>DOM树含有很多不可见的元素，比如head标签，或者display:none的元素，所以再显示之前， 需要额外的构建一颗<strong>只包含可见元素的布局树</strong></p><p>为了构建布局树，浏览器大体上完成了下面这些工作：</p><p><img src="'+t+'" alt=""></p><ul><li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；</li><li>而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。</li></ul><h3 id="_2-布局计算-1" tabindex="-1">2.布局计算 <a class="header-anchor" href="#_2-布局计算-1" aria-label="Permalink to &quot;2.布局计算&quot;">​</a></h3><p>这个阶段主要计算布局树节点的坐标位置，把布局运算的结果写到布局树中保存起来；</p><h2 id="分层-1" tabindex="-1">分层 <a class="header-anchor" href="#分层-1" aria-label="Permalink to &quot;分层&quot;">​</a></h2><blockquote><p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等， 为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）</strong></p></blockquote><blockquote><p>渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面</p></blockquote><p>图层和布局树节点之间的关系:</p><p><img src="'+p+'" alt=""></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</p></div><p>渲染引擎会为以下情况的节点创建新的图层：</p><ul><li>拥有层叠上下文属性的元素会被提升为单独的一层</li><li>需要剪裁（clip）的地方也会被创建为图层</li></ul><h2 id="绘制-1" tabindex="-1">绘制 <a class="header-anchor" href="#绘制-1" aria-label="Permalink to &quot;绘制&quot;">​</a></h2><blockquote><p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制</p></blockquote><p>渲染引擎实现图层的绘制跟我们绘制canvas类似，会把一个图层的绘制拆分成很多小的绘制指令， 然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</p><p><img src="'+e+'" alt=""></p><p>实际的绘制列表可以再chrome devtools的layers标签查看:</p><p><img src="'+r+'" alt=""></p><h2 id="光栅化-分块-1" tabindex="-1">光栅化 &amp; 分块 <a class="header-anchor" href="#光栅化-分块-1" aria-label="Permalink to &quot;光栅化 &amp; 分块&quot;">​</a></h2><blockquote><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的</p></blockquote><p><img src="'+c+'" alt=""></p><p>当图层的绘制列表准备好之后，主线程会把该绘制列表<strong>提交commit</strong>给合成线程</p><blockquote><p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口， 用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销， 而且也没有必要。</p></blockquote><p>基于这个原因，合成线程会将图层划分为<strong>图块（tile）</strong></p><blockquote><p>图块的大小通常是 256x256 或者 512x512</p></blockquote><p><strong>合成线程</strong>会按照视口附近的图块来优先生成位图，实际生成位图的操作是由<strong>栅格化</strong>来执行的。 所谓栅格化，是指将图块转换为<strong>位图</strong></p><p><img src="'+i+'" alt=""></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>图块是栅格化执行的最小单位</p></div><p>通常，栅格化过程都会使用 <strong>GPU</strong> 来加速生成，使用 <strong>GPU</strong> 生成位图的过程叫<strong>快速栅格化</strong>，或者 <strong>GPU</strong> 栅格化，生成的位图被保存在 <strong>GPU</strong> 内存中。</p><p><strong>快速栅格化：</strong><img src="'+g+'" alt=""></p><blockquote><p>渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。</p></blockquote><h2 id="合成显示" tabindex="-1">合成显示 <a class="header-anchor" href="#合成显示" aria-label="Permalink to &quot;合成显示&quot;">​</a></h2><ol><li>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</li><li>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</li></ol><h2 id="渲染流程总结" tabindex="-1">渲染流程总结 <a class="header-anchor" href="#渲染流程总结" aria-label="Permalink to &quot;渲染流程总结&quot;">​</a></h2><p><img src="'+d+'" alt=""></p><ol><li>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</li><li>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</li></ol><h2 id="渲染流程总结-1" tabindex="-1">渲染流程总结 <a class="header-anchor" href="#渲染流程总结-1" aria-label="Permalink to &quot;渲染流程总结&quot;">​</a></h2><p><img src="'+d+'" alt=""></p>',125),y=[C];function q(F,k,_,A,P,B){return b(),D("div",null,y)}const f=u(m,[["render",q]]);export{S as __pageData,f as default};
