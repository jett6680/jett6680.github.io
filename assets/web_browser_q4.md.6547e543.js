import{_ as e,o as a,c as o,O as t}from"./chunks/framework.64ff6dc7.js";const c="/assets/img_28.png",r="/assets/img_29.png",l="/assets/img_30.png",q=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"web/browser/q4.md","lastUpdated":1739458337000}'),i={name:"web/browser/q4.md"},s=t('<h2 id="什么是缓存" tabindex="-1">什么是缓存 <a class="header-anchor" href="#什么是缓存" aria-label="Permalink to &quot;什么是缓存&quot;">​</a></h2><blockquote><p>HTTP缓存是一种机制，它允许浏览器在本地存储Web资源的副本，以便在下次访问相同资源时， 可以直接从本地获取而不是重新从服务器下载。这种机制可以节省网络流量并减少页面加载时间，因为浏览器不必每次都从服务器请求资源。 在这个过程中，HTTP缓存可以帮助减少网络流量和提高页面加载速度，从而提供更好的用户体验。</p></blockquote><p><img src="'+c+'" alt=""></p><p>在Network面板中的size列表里，会看到两种标识：<code>from memory cache </code>和 <code>from disk cache</code> 字样， 这就说明该资源来自缓存，memory cache 表示缓存来自<strong>内存</strong>，disk cache 表示缓存来自<strong>硬盘</strong></p><p>HTTP缓存中有两种缓存方式：</p><ol><li>强制缓存</li><li>协商缓存</li></ol><h2 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h2><blockquote><p>判断缓存是否过期，如果没过期，直接使用。如果过期了，就请求服务器，获取最新的资源</p></blockquote><p>第一次访问页面，浏览器会根据Response Header来判断是否对资源进行缓存， 如果响应头中有 <code>cache-control: max-age=2952000</code> 或 <code>expires</code> 字段，代表该资源是强缓存</p><p><img src="'+r+'" alt=""></p><h2 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h2><blockquote><p>浏览器携带缓存标识向服务器发送请求，服务器根据缓存标识来决定该资源是否过期</p></blockquote><p>协商缓存的条件:</p><ul><li>Cache-Control 的值为 no-cache （协商缓存）</li><li>或者 Cache-Control: max-age=0</li></ul><p><img src="'+l+'" alt=""></p><h2 id="expires" tabindex="-1">Expires <a class="header-anchor" href="#expires" aria-label="Permalink to &quot;Expires&quot;">​</a></h2><blockquote><p>是HTTP1.0控制网页缓存的字段，值为一个时间戳，服务器返回该资源缓存的到期时间, 但 Expires 有个缺点，就是它判断是否过期是用<strong>本地时间</strong>来判断的，本地时间是可以自己修改的,这样会导致缓存失效; 到了HTTP/1.1，Expire 已经被 Cache-Control 替代，Cache-Control 使用了max-age<strong>相对时间</strong>，解决了Expires 的缺陷</p></blockquote><div class="danger custom-block"><p class="custom-block-title">注意</p><p>当 Cache-Control 与 expires 两者都存在时，Cache-Control 优先级更高</p></div><h2 id="cache-control" tabindex="-1">Cache-Control <a class="header-anchor" href="#cache-control" aria-label="Permalink to &quot;Cache-Control&quot;">​</a></h2><blockquote><p>HTTP1.1 中控制网页缓存的字段</p></blockquote><p>主要取值为：</p><ul><li>public：资源客户端和中间代理服务器都可以缓存</li><li>private：资源只有客户端可以缓存,中间代理服务器不可以缓存</li><li>no-cache：客户端缓存资源，但是是否缓存需要经过协商缓存来验证</li><li>no-store：不使用缓存</li><li>max-age：缓存保质期，是相对时间</li></ul><div class="danger custom-block"><p class="custom-block-title">注意</p><p>实际上Cache-Control: no-cache 是会被缓存的，是协商缓存的标识，只不过每次都会向服务器发起请求，来验证当前缓存的有效性 Cache-Control: no-store：这个才是响应不被缓存的意思</p></div><h2 id="last-modified" tabindex="-1">Last-Modified <a class="header-anchor" href="#last-modified" aria-label="Permalink to &quot;Last-Modified&quot;">​</a></h2><blockquote><p>文件在服务器最后被修改的时间，从服务器 Response Headers 上获取</p></blockquote><h3 id="验证流程" tabindex="-1">验证流程 <a class="header-anchor" href="#验证流程" aria-label="Permalink to &quot;验证流程&quot;">​</a></h3><h2 id="etag" tabindex="-1">ETag <a class="header-anchor" href="#etag" aria-label="Permalink to &quot;ETag&quot;">​</a></h2><h3 id="memory-cache-与-disk-cache-的区别" tabindex="-1">memory cache 与 disk cache 的区别？ <a class="header-anchor" href="#memory-cache-与-disk-cache-的区别" aria-label="Permalink to &quot;memory cache 与 disk cache 的区别？&quot;">​</a></h3><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>未完成待续。。。。</p>',30),n=[s];function h(d,p,m,u,b,_){return a(),o("div",null,n)}const g=e(i,[["render",h]]);export{q as __pageData,g as default};
