import{_ as o,o as t,c as a,O as e}from"./chunks/framework.64ff6dc7.js";const l="/assets/img_7.png",r="/assets/img_8.png",i="/assets/img_9.png",s="/assets/img_10.png",c="/assets/img_11.png",P=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"web/browser/q1.md","lastUpdated":1739457513000}'),n={name:"web/browser/q1.md"},p=e('<h2 id="chrome的多进程架构" tabindex="-1">chrome的多进程架构 <a class="header-anchor" href="#chrome的多进程架构" aria-label="Permalink to &quot;chrome的多进程架构&quot;">​</a></h2><h2 id="什么是线程" tabindex="-1">什么是线程 <a class="header-anchor" href="#什么是线程" aria-label="Permalink to &quot;什么是线程&quot;">​</a></h2><blockquote><p>是操作系统能够进行运算调度的最小单位</p></blockquote><h2 id="什么是进程" tabindex="-1">什么是进程 <a class="header-anchor" href="#什么是进程" aria-label="Permalink to &quot;什么是进程&quot;">​</a></h2><blockquote><p>一个进程就是一个程序的运行实例,启动一个程序的时候，操作系统会为该程序创建一块内存， 用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。</p></blockquote><h2 id="进程-vs-线程的特点" tabindex="-1">进程 vs 线程的特点 <a class="header-anchor" href="#进程-vs-线程的特点" aria-label="Permalink to &quot;进程 vs 线程的特点&quot;">​</a></h2><p><img src="'+l+'" alt="img_7.png"></p><div class="tip custom-block"><p class="custom-block-title">知识</p><p>线程是不能单独存在的，它是由进程来启动和管理的。线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。</p></div><p><strong>特点</strong></p><ul><li>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</li><li>线程之间共享进程中的数据。</li><li>当一个进程关闭之后，操作系统会回收进程所占用的内存。</li><li>进程之间的内容相互隔离。</li></ul><h2 id="单进程浏览器时代" tabindex="-1">单进程浏览器时代 <a class="header-anchor" href="#单进程浏览器时代" aria-label="Permalink to &quot;单进程浏览器时代&quot;">​</a></h2><blockquote><p>早在 2007 年之前，市面上浏览器都是单进程的。浏览器的所有功能模块都是运行在同一个进程里， 这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。</p></blockquote><p><img src="'+r+'" alt="单进程浏览器架构图"></p><p>因为这么多的功能模块都运行在一个进程里，所以单进程浏览器有很多问题。</p><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ol><li>不稳定 <br><blockquote><p>一个模块功能运行出现崩溃，会导致整个浏览器崩溃；</p></blockquote></li><li>不流畅 <br><blockquote><p>所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。从而导致页面渲染不流畅;</p></blockquote></li><li>不安全 <blockquote><p>插件和js脚本没有运行在沙箱，能够轻松访问系统的任意资源，可能会存在恶意脚本攻击电脑；</p></blockquote></li></ol><h2 id="多进程浏览器时代" tabindex="-1">多进程浏览器时代 <a class="header-anchor" href="#多进程浏览器时代" aria-label="Permalink to &quot;多进程浏览器时代&quot;">​</a></h2><h3 id="早期多进程架构" tabindex="-1">早期多进程架构 <a class="header-anchor" href="#早期多进程架构" aria-label="Permalink to &quot;早期多进程架构&quot;">​</a></h3><p>早期Chrome浏览器发布的时候的进程架构图 <img src="'+i+'" alt=""></p><blockquote><p>页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信（如图中虚线部分）。</p></blockquote><h3 id="目前的多进程架构" tabindex="-1">目前的多进程架构 <a class="header-anchor" href="#目前的多进程架构" aria-label="Permalink to &quot;目前的多进程架构&quot;">​</a></h3><p><img src="'+s+'" alt=""></p><blockquote><p>最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。</p></blockquote><p>每个进程的功能如下：</p><ul><li>浏览器进程。</li></ul><blockquote><p>主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p></blockquote><ul><li>渲染进程。</li></ul><blockquote><p>核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p></blockquote><ul><li>GPU 进程。</li></ul><blockquote><p>其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p></blockquote><ul><li>网络进程。</li></ul><blockquote><p>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</p></blockquote><ul><li>插件进程。</li></ul><blockquote><p>主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p></blockquote><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p><ol><li><strong>更高的资源占用</strong>。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li><li><strong>更复杂的体系架构</strong>。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li></ol><blockquote><p>为了解决这些问题，在 2016 年，Chrome 官方团队使用“<strong>面向服务的架构</strong>”的思想设计了新的 Chrome 架构。 Chrome 最终要把 <strong>UI</strong>、<strong>数据库</strong>、<strong>文件</strong>、<strong>设备</strong>、<strong>网络</strong>等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型图：</p></blockquote><p><img src="'+c+'" alt=""></p>',39),h=[p];function u(b,q,m,d,k,_){return t(),a("div",null,h)}const f=o(n,[["render",u]]);export{P as __pageData,f as default};
